## 快速排序

快速排序是一种相对冒泡排序、选择排序等算法来说性能比较好的排序算法，时间复杂度是O(nlogn)。关于它的理论说法是使用的所谓的分治法，其实说白了就是每次都选择一个数组中的元素作为基准值，小于它的值放在左边，大于它的值放在右边。然后继续对基准值的左边和右边做同样的操作，选一个基准值，再分成大小两部分，知道最后子数组无法继续分割的时候排序也就完成了。所以可以看出快速排序其实是对递归的一种高度依赖。



1. 递归

   上面讲到了递归，要学会快速排序必须对递归的理论非常清晰，首先递归就是自己调用自己，所有递归一定会有两个条件。
   
   - 基线条件
     
     基线条件就是判断在何种情况下，就不需要再继续调用自己了，这样可以避免死循环。
      
   - 递归条件

     递归条件则是什么情况下，需要继续调用自己，这样可以确保把所有的数据都计算到位。

   - 递归相加的例子

     下面是一个最简单的递归例子，递归相加数组，它的基线条件是数组为空或者只有一个元素的时候，如果不满足这个条件就会一直递归下去，可以看到每次递归都是取出数组的第一个元素，然后把后面的元素继续递归递调用，也就是说最后一次递归是原始数组的倒数第一个元素和第二元素相加，接着满足了基线条件开始返回结果给上次调用，逐层相加，最后就获得了整个数组的和。

     ```
     public static int recursion(int[] arr) {
         // 基线条件:数组为空或者数组长度为1
         if (arr == null || arr.length < 1) {
             return 0;
         } else {
             // 每个都元素加上递归返回的结果
             return arr[0] + recursion(Arrays.copyOfRange(arr, 1, arr.length));
         }
     }
     ```

2. 快速排序例子

   上面之所以讲递归的原理，是因为快速排序的核心其实就是递归，但是相较于上面那个递归相加来看，快速排序的递归代码要复杂得多。从下列的代码来看会发现本质上就是在方法中选一个基准值然后开始把其他的值分为两部分，左边的是小于基准值的，右边的是大于基准值的，然后再继续递归调用处理基准值左边和右边的元素，直到最后满足基线条件，递归终止，排序也就完成了，要注意的就是因为索引的频繁交换，需要增加各种判断来保证交换的逻辑正确性。下面只是最基础的版本，还有更复杂的优化版，都是在这个基础上进行的。
   
   比如以下面这个数字为例子，就可以清晰的看到，选了3作为基准值，然后开始左右调换数字，把小的放左边，大的放右边，最后再把3放到中间。然后继续递归排序3左边的和右边，每次都选第一个为基准值，做重复的逻辑，一直递归到范围是两个数字，排序完之后也就无序继续递归了，这就是分而治之的原理，把整体都拆分成最小的局部个体，然后保证每个局部个体都正确，合到一起的整体也就正确。
   ```
   初始数组 [3,5,2,1]，每次都选第一个为基准值
   第一轮：
   基准值为3，左索引0，右索引3
   [3,1,2,5]从左边找比3小的，从右边找比3大的，进行交换
   [2,1,3,5]将基准值放入中间位置
   第二轮，递归排序基准值左右两边的数值：
   排序左边，基准值为2，左索引0，右索引1
   [2,1,3,5]从左边找比2小的，从右边找比2大的，进行交换
   [1,2,3,5]将基准值放入中间位置
   排序右边，基准值为3，左索引2，右索引3
   [2,1,3,5]从左边找比2小的，从右边找比2大的，进行交换
   [1,2,3,5]将基准值放入中间位置
   ```

   ```
	public static void quick(int[] arr, int start, int end) {
		
		// 中断递归的条件，大于一个元素才有可比性
		if (start >= end) {
			return;
		}

		// 两个用来遍历数组中的元素是大于还是小于基准值的索引
		int left = start;
		int right = end;

		// 基准值，这里选择的第一个
		int baseValue = arr[left];

		// 因为是分别从两头开始遍历元素，所以如果两个索引一样了就表示撞到一起了
		while (left != right) {
			
			// 从最右边开始遍历，找到小于基准值的元素就停止
			while (left < right && arr[right] >= baseValue) {
				right--;
			}
			
			// 从最左边开始遍历，找到大于基准值的元素就停止
			while (left < right && arr[left] <= baseValue) {
				left++;
			}
			

			// 起始索引比终止索引要小，还没遍历完，走到这步表示分别找到了大于基准值和小于基准值的数，交换他们的位置
			if (left < right) {
				int temp = arr[left];
				arr[left] = arr[right];
				arr[right] = temp;
			}
		}

		// 走到这步表示上面的遍历已经完成了，需要把基准值和索引最后停留的位置交换，这个位置就是左边比基准值小右边比基准值大
		// 但是因为是递归，有可能会有两个元素的情况，这个时候就要直接判断两个值的大小来看是否要交换
		if (arr[start]>arr[left]) {
			int temp = baseValue;
			arr[start] = arr[left];
			arr[left] = temp;
		}

		// 上面是完整的一整套将小于基准值的数放到左边，大于的数放到右边
		// 下面就是分别递归计算左边的值和右边的值，注意传入的索引就分别是左边部分的起始位置和右边部分的起始位置
		quick(arr, start, left - 1);
		quick(arr, left + 1, end);
	}
   ```

3. 时间复杂度

   因为快速排序的效率是高度依赖选择的基准值的，比如一个已经排好序的数组，[1,2,3,4]，如果基准值选择的是1，那每个元素都要递归4次，因为每次递归因为左边的每次递归左边的数组都是空的，元素全在右边，这是最糟糕的情况，再加上每个元素都要遍历，所以时间复杂度是O(n²)，而如果基准值选择的是中值，那只要2次就可以递归完，因为每次都是对折，所以时间复杂度是O(logn)，所以整体时间复杂度是O(nlogn)。一般只要每次的基准值都是随机选择的，那就可以保证时间复杂度是O(nlogn)，至于原理就牵扯到一些复杂的算法定律，比如随机算法之类的，有兴趣的可以自行了解。

