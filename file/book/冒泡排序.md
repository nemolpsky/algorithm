### 冒泡排序

冒泡排序算是最简单的排序方式，思路非常简单。
- 从第一个元素开始，往后遍历，比较当前元素和后面那个元素的大小
- 如果当前元素的下一元素值更小则交换两个元素的位置
- 一直重复这个步骤，知道最后一个元素

下面这个动图就是冒泡排序的过程，其实就是每个元素都跟其他所有的元素比较大小，小的放前面大的放后面，所有的元素都按照个逻辑走一遍，自然也就是保持顺序的了。

![冒泡排序](https://github.com/nemolpsky/algorithm/raw/master/file/data/image/bubbleSort.gif)



具体实现就是一个双层循环，第一层是遍历元素，第二层则是和其他元素一次进行比较，因为本质上每完成一轮最里面的循环就会把一个本轮最大的元素放到后面。假设长度为n，第一轮循环就是把最大的值放在n-1索引上，第二轮则是找出第二大的值放在n-2的位置上，依次类推，越往后遍历的长度就越短，这也是为什么第二层循环会使用```j<len-1-i```，每一轮循环都会找出一个最大值，所以越往后，后面那些排好序的元素就不需要对比了。

这种双层循环时间复杂肯定是O(n²)，一般也不会有人使用，毕竟JDK类库自带的排序都不会用这种实现。

```
    static void bubbleSort(int[] arr) {
        int len = arr.length;
        for (int i = 0; i < len - 1; i++) {
            for (int j = 0; j < len - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {       // 相邻元素两两对比
                    int temp = arr[j + 1];       // 元素交换
                    arr[j + 1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }
```