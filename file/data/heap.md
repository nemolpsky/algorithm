## 堆

堆其实是一种特殊的二叉树，所以也被称作二叉堆，它有着和二叉树一样的结构，除了叶子节点外每个节点都必定有两个子节点，此外堆还是一棵完全树，也就是说除了最后一层节点之外其他层的节点全都是满的。


---


1. 堆的性质
   - 任意节点都大于(或小于)它的子节点，并且在堆的根节点上一定是最大节点(或最小节点)。
   - 堆是一棵完全树，除了最后一层节点之外其他层的节点都会被填满，并且底层尽量从左往右填入元素。



2. 堆的时间复杂度
    ```
    操作                     时间复杂度
    创建空堆                  O(n)
    插入新元素                O(logn)
    获取堆顶元素              O(1)
    删除堆顶元素              O(logn)
    ```


3. 大顶堆和小顶堆
   - 大顶堆

     大顶堆就是根节点是最大的值，然后堆中所有的节点都比它的左右子节点要大。

     ```
                       13
                    /       \  
                16          31 
               /   \        /    \
            41    51  100   41
     ```
   - 小顶堆

     小顶堆就是根节点是最小的值，然后堆中所有的节点都比它的左右子节点要小。

     ```
                        9
                    /       \  
                  8          6 
               /   \        /    \
             5     4     3       1
     ```

4. 堆的应用场景

   堆很适合应用于top K问题，top K问题就是在一堆无序的数字中找到最大或最小的K个数，或者是第K大和第K小的数。
   
   以求最大K个数为例子，可以使用快速排序，时间复杂度是O(nlogn)，或者是使用分治法，也就是类似快排的操作，随机选一个数t，以t为基准值分左大右小两组，如果左边总数大于K个就在继续在左边找，否则找右边，直到刚好左边个数等于K时就找到了，时间复杂度是O(n)。

   上面的方法虽然都可以解决但是时间复杂度都比较高，而且如果遇到了数据量特别大的时候对空间的消耗也必须考虑进去，而堆就可以很好的解决这个问题，只需要一次遍历，极少的空间消耗。

5. 堆解决top K问题

   比如数组[1，8，3，77，6，2]，找出前三个最大的数，先构建出一个容量为3的小顶堆。
   ```
           1
         /   \
       8       3
   ```
   继续遍历到77，77比1大，所以77替换1，并且需要调整堆结构以保证它符合堆的特性，可以看到3成为堆顶了。
   ```
           3
         /   \
       8      77
   ```
   遍历到6时，6就替换了3，堆结构则不需要调整，然后到2，2比6小直接忽略。可以看到堆中的这三个数就是最大的三个数了，并且堆顶就是第3个最大的数。只需要存储3个数的空间就可以，并且只需要遍历一次，如果是求最小的三个数使用最大堆就可以。
   ```
           6
         /   \
       8      77
   ```

6. Java中堆的实现

   Java中的PriorityQueue优先队列底层结构就是使用的堆，每次替换完堆顶元素之后会自动调整堆结构，使用起来非常方便，下面就是用PriorityQueue来解决top K问题，队列中存储的就是前3个最大的数，队列顶端的元素就是第三大的数。

   ```
    public static void main(String[] args) {

        int[] arr = new int[]{5, 89, 6, 7, 3, 55, 6};
        Queue<Integer> queue = new PriorityQueue<Integer>();

        for (int num : arr) {
            // 只存储3个数
            if (queue.size() < 3) {
                queue.add(num);
            } 
            // 超过3个数则比较堆顶判断是否需要替换堆顶
            else if (queue.peek() < num) {
                queue.poll();
                queue.add(num);
            }
        }

        while (!queue.isEmpty()) {
            System.out.println(queue.poll());
        }
    }
   ```